KidPwn
---------------
pwn , 424pts

desc 
---------------
```
```

- FSB
- ROP


files 
---------------
- challenge 
- libc.so.6(glibc 2.23->ubuntu 16.04)


checksec 
---------------
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled


solution 
---------------

프로그램 시작시 전역변수 20105C 영역에 값이 있는지를 체크하고, 있으면 v7변수에 200을, 
값이 없을때는 fgets로 표준입력을 받아 입력값이 들어오면 atoi함수로 숫자로 변환한 값을 넣는다. 
이후 alloca 함수를 이용해 16*((입력한 값+30)/10) 만큼 스택 프레임 내에 공간을 할당한다. 
그다음 전역변수 201050 영역에 지역변수 포인터를 복사하고, read함수를 통해 해당 위치에 v7변수의 값만큼 입력을 받는다. 
그다음 printf 함수를 통해 해당 내용을 출력하는데 서식문자 없이 변수 포인터를 그대로 가져온다. 즉, fsb가 유발된다. 
출력 이후 20105C 영역에 값이 있는지를 체크하여 있으면 read함수를 통해 스택에 0바이트만큼 입력을 받고 printf-exit순으로 실행되어 프로그램이 종료되고 
그렇지 않으면 20105C를 1 더하고 프로그램을 종료한다. 

fsb를 유발하여 주소를 leak한 다음 프로그램의 루틴이 if문 내로 진입하게끔 바꾸고, (main함수를 다시 실행하거나 if문 내로 바로 진입하는 식.)
relro가 partial이기 때문에 got overwrite를 이용하여 read나 exit 함수를 바꾸는 식으로 exploit이 될거같다. 

%lx를 입력하면 현재 스택주소가 그대로 나오는걸 볼 수 있다. 
문자열이 들어간 스택의 주소가 그대로 출력되고 있다. 
6개 입력시 6번째부터 입력한 문자열들이 나온다. 

100 입력시 rsp : 0x630 -> rbp : 0x720 (100+30 / 10 * 16 => 13*16 = D0으로 F0와 0x20만큼 차이. 
130을 입력하면 16*16 = 100, 스택의 주소는 120만큼 차이가 나야한다. 실제로는 0x110 차이가 났다. 
90을 입력하면 12*16 = C0, 스택의 주소는 E0만큼 차이가 나야한다. 이 경우는 E0가 맞았다.

시나리오를 구상해보면 첫째 입력시에 libc와 스택주소를 leak하고 프로그램이 다시 실행되게끔 조작을 해야하는데
조작할만한 루틴이 안보인다. ret를 덮어씌우자니 pie가 걸려있어 코드 주소를 바로 넣을수도 없는 상황. 
방법을 생각해보자... 

일단 ret가 들어있는 위치의 주소를 찾고 , 해당 위치의 코드 주소의 하위 바이트를 조작하는 방법을 이용하면 전체 바이트를 다 바꾸지 않고도 원하는 위치로 점프시킬수는 있어보인다. 
스택상에서 rbp의 주소가 있는부분은 찾을 수 있지만 ret의 주소를 바로갖고 있는 영역은 없었다.
따라서 ret의 하위 1바이트만 바꾸어 main함수로 진입하게 만들어줬다.

일단 지금까지의 순서는, 첫번쨰 입력후 printf 때 주소 leak을 하면서 ret주소를 덮어씌워 다시 메인함수로 돌아오게 만든다.
그 다음, 두번째 read가 실행되게 만들어 printf 시 exit함수의 got를 덮어씌우는 식인데
exit함수에서 원샷가젯을 바로 실행시키니 rsi 인자때문에 제대로 실행이 안되더라. 

rsi 인자를 바꾸는 방법을 찾거나, 다른 방법을 동원해봐야 한다. 
원샷가젯을 바로 쓰는 대신, 그냥 exit함수의 got를 이용해 rop를 진행해볼 수도 있지 않을까?
exit 함수의 got를 pop*7-ret 가젯으로 대신 덮고, 스택의 8번째부터 원샷가젯을 실행시키는 rop 코드를 넣어주었다.


```
payload2 = w1+" "*(8-len(w1))
payload2 += "%15$hn  "
payload2 += w2+" "*(8-len(w2))
payload2 += "%16$hn  "
payload2 += w3+" "*(8-len(w3))
payload2 += "%17$hn  "
# pop rsi -> 0 -> oneshot gdaget
payload2 += p64(p_rs)
payload2 += p64(0)
payload2 += p64(oneshot)
# overwrite exit_got to pop*7 ret gadget  
payload2 += p64(code+exit_got)  #one[3] - 15
payload2 += p64(code+exit_got+2)#one[2] - 16
payload2 += p64(code+exit_got+4)#one[1] - 17
```

풀이 완료.












