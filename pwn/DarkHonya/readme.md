Dark honya
---------------
pwn , 437pts

desc 
---------------
```
```

files 
---------------
-challenge 
-libc.so.6(glibc 2.23->ubuntu 16.04)


checksec 
---------------
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)



solution 
---------------
프로그램을 실행하면 이름 0xF8 바이트만큼 입력받고, 5개의 메뉴를 선택할 수 있다. 

1번은 buy, malloc으로 F8바이트 동적할당 받으면서 문자열을 저장한다. 
최대 15개까지 만들 수 있고, 포인터 배열에 메모리의 주소값을 저장한다. 

2번은 back. 인덱스를 선택해 할당한 메모리를 할당 해제하고, 포인터에 배열에 0을 넣는다. 
메모리 내용의 초기화는 이뤄지지 않고, 포인터를 0으로 만들기에 더블프리는 힘들어뵌다. 

3번은 write. 할당한 메모리의 값을 수정한다. 포인터 배열을 통해 값을 가져오기때문에
할당 해제한 메모리에 바로는 쓸 수 없다. 
수정할때는 최대 F8만큼 쓸 수 있다. 

4,5번과 그 외 입력은 프로그램을 종료시키는데 5번은 return 동작을, 
나머지는 exit()함수를 호출한다. 

정리하면 
1. 더블프리 불가
2. 할당해제 메모리에 쓰기 불가
3. 할당 해제 메모리의 포인터 배열은 0으로 초기화. 
4. 할당 해제된 메모리는 초기화 X
5. F8크기 메모리 선언
6. F8바이트 입력. 
7. 메모리 출력구문 없음
8. GOT overwrite 가능. 
9. smallbin chunk 이므로,인접한 청크 할당 해제시 병합되고 FIFO 구조임.

이후 buy 함수를 좀 더 분석해보면, 

```
for ( i = 0; ptr[i]; ++i )
```
입력받을 배열 인덱스인 i를 결정할 때, ptr[i]의 값이 0인지를 체크하여 결정한다.
할당 해제 후 재할당시 메모리상 순서와 인덱스상 순서를 다르게 만들수도 있다.

결국 입력값을 통해 조작할 수 있는건 우선은 prev_size 뿐이라는 이야기.

5번과 6번을 이용해보자. F8크기 청크를 할당하면 0x100만큼 청크가 할당되면서 
맨 처음 16바이트는 prev_inuse와 size 영역으로 사용되어 실제 사용 가능한 메모리는 F0바이트뿐이다.
이떄 F8만큼 입력을 넣으면 현재 청크를 전부 덮은 후에 다음청크의 prev_size까지 덮게되는데, 이후에 다음 청크의 size가 위치한다.
size의 마지막 1바이트는 prev_inuse, 즉 이전청크가 free된 청크인지를 체크하는  비트를 가지고있다. 
현재 청크의 이전청크가 F8바이트만큼 입력을 꽉 채워서 보내면 해당 prev_inuse 비트가 NULL바이트로 덮이는 현상이 발생하여
방금전에 입력을 넣어줬던 청크가 free된 청크로 취급되게 된다.

이후에 해당 청크와 인접한 청크를 할당 해제하면 두 청크가 병합되는 현상이 발생한다.
이게 unlink인데, 언링크를 이용하는 주 목적은 FD와 BK를 조작하여 원하는 위치에 값을 할당하기 위함이다. 

```
chunksize(P) != prev_size (next_chunk(P)
```
unlink시에 발생할 수 있는 오류중 corrupted size vs. prev_size 오류가 있다.
이는 free된 청크 다음 청크는 이전 청크(free된 청크)의 크기를 prev_size 영역에 가지고 있는데,
해당값과 free되었던 청크의 크기가 일치하지 않으면 발생한다. 
다만 이 값을 찾아오는 루틴을 정확하게 체크해보면, 
```
0x00 | chunk1 prev_size | chunk1 size 
0x10 |            fd    |  bk
                   ..........
0x50 | chunk2 prev_size | chunk2 size
```
위와같이 되어있을 때 chunk2의 free로 인해 chunk1이 unlink 되면 chunk2의 prev_size를 우선 읽어온 다음,
chunk2 size "위치" 로부터 prev_size 만큼 떨어진 위치에 같은값이 있는지를 체크한다. 
만일 0x50위치에 있는 prev_size의 값이 0x50이라면 0x58 - 0x50 인 0x08위치에 0x50이 있는지를 확인한다는 소리이다.
그렇게 하면 unlink는 해당 위치인 0x0 부터가 청크의 영역이라고 인식한다. 

```
FD->bk != P || BK->fd != P
```

그 다음, 현재청크의 fd -> bk 값과 bk -> fd 값을 가져와 현재 청크의 주소값과 일치하는지 비교한다.
뭔소린가 하면, 할당 해제된 청크들은 list를 이루는데, 
현재청크의 fd청크, 즉 리스트의 앞에 위치한 청크의 리스트 다음에 위치한 청크주소값을 저장하는 bk의 값을 가져온다는 이야기.
리스트상 현재청크의 -> 이전청크의 -> 다음청크는 -> 다시 현재청크이니까, 현재 청크의 주소값과 일치해야 한다.
bk->fd도 같은이야기. 리스트상 현재청크의 -> 다음청크의 -> 이전청크는 다시 현재청크이다. 
청크에서 fd와 bk는 각각 청크 시작주소의 +0x10, +0x18 떨어진 곳에 위치한다. 
즉, 특정 메모리 위치에 현재청크의 주소값이 있어야 하는데 지금 당장 힙영역의 주소를 알아낼 수는 없으므로,
힙 주소를 가진 전역변수 포인터 배열을 가져와서 활용해야한다. 

만약, i번째 인덱스를 가진 청크가 unlink가 되려면 포인터배열 + [i*8] 에 담겨있는 주소를 찾아가야 하므로,
fd에는 포인터배열 + [i*8]-0x18(bk), bk에는 포인터배열 + [i*8]-0x10(fd)값이 들어가야 한다. 
```
ptr = 0x06021A0
fd = ptr+(2*8)-0x18
bk = ptr+(2*8)-0x10

str1 = p64(fd)
str1 += p64(bk)
str1 += "a"*0xe0
str1 += p64(0x100)
mod(2,str1)   #2
```
3번째 청크를 조작하는 경우의 예시. 
다만 이렇게 하면 여전히 에러가 발생하는데, 그 이유는 포인터 배열에 담기는 주소값이 힙의 주소값 그대로가 아닌,힙의 주소값+0x10 만큼 담기기 때문이다. 
따라서, 위에서 청크를 구성할 때 unlink가 청크위치+0x10 위치부터를 청크라고 인식하게 만들어야 하므로,
prev_size 와 size를 0x100이 아닌 0xF0로 세팅하는 가짜 청크를 만들어줘야 한다. 
```
0x24fd210:      0x0000000000000000      0x00000000000000f0
0x24fd220:      0x0000000000602198      0x00000000006021a0
0x24fd230:      0x6161616161616161      0x6161616161616161
0x24fd240:      0x6161616161616161      0x6161616161616161
0x24fd250:      0x6161616161616161      0x6161616161616161
0x24fd260:      0x6161616161616161      0x6161616161616161
0x24fd270:      0x6161616161616161      0x6161616161616161
0x24fd280:      0x6161616161616161      0x6161616161616161
0x24fd290:      0x6161616161616161      0x6161616161616161
0x24fd2a0:      0x6161616161616161      0x6161616161616161
0x24fd2b0:      0x6161616161616161      0x6161616161616161
0x24fd2c0:      0x6161616161616161      0x6161616161616161
0x24fd2d0:      0x6161616161616161      0x6161616161616161
0x24fd2e0:      0x6161616161616161      0x6161616161616161
0x24fd2f0:      0x6161616161616161      0x6161616161616161
0x24fd300:      0x00000000000000f0      0x0000000000000100
```
이렇게 세팅하고 해당 청크의 다음번 청크를 free 하면 두 청크간 unlink가 발생해 병합된다. 
unlink가 발생한 다음에는 0x24fd220 에 넣어준 0x24fd220의 주소값을 가지고 있는 위치, 즉 포인터 배열인 0x06021A0+0x10 에 가짜청크의 fd가 들어간다. 
왜 이렇게 되냐면, 리스트가 이어져 있을때에 가운데 메모리가 free되면 리스트 중간에서 빠져나가는거니까 이전/이후 청크끼리 연결해줘야한다. 
```
P-1 	|      P      |	P+1
<-fd	|   <-fd(P-1) |	<-fd(P)
bk(P)-> |	bk(P+1)-> |	bk->

P-1      |    P+1
<-fd     | <-fd(P-1)      
bk(P+1)->|    bk->
```
그래서 이전청크의 bk 는 현재청크의 bk인 P+1이 되는거고 이후 청크의 fd는 현재 청크의 fd인 P-1이 된다. 
이걸 그대로 옮겨오면, 이전청크(602198 위치)의 bk(602198+0x18 = 0x6021b0 위치)는 P+1인 0x6021a0이 되고,
다음청크(0x6021a0 위치)의 fd(0x6021a0+0x10 = 0x6021b0 위치)는 P-1인 0x602198이 되는거다. 
저 두 동작이 동일한 메모리 영역인 0x6021b0에 순서대로 발생했기 때문에 먼저 0x6021a0 이 덮어 씌워지고, 0x602198이 한번 더 덮어 씌워져서 저런 결과가 나왔다. 
```
0x6021a0:       0x00000000024fd010      0x00000000024fd110
0x6021b0:       0x0000000000602198      0x0000000000000000
0x6021c0:       0x00000000024fd410      0x0000000000000000
```
이렇게 되면, 포인터 배열의 세번째값을 수정하면 0x602198위치에 값이 입력된다.  
해당 위치 또한 포인터 배열이므로, 내가 덮어쓰고 싶은 위치가 있다면 그 위치의 주소값을 저 위치에 적어주면 된다! 
이렇게 하면 몇번이고 원하는 주소 위치를 덮어씌울 수 있다. 
GOT overwrite가 가능하니까 이를 통해 주소값을 leak 하고 원샷 가젯까지 덮어보자. 
여기서 약간의 꼼수가 필요한데, libc leak을 위해서는 여러 함수의 got를 출력함수의 것으로 바꿔볼 수 있다. 
그러나 free를 제외하면 직접적으로 주소값을 사용하는 함수는 없어보이는데, atoi 함수를 보면 입력값을 인자로 호출된다.
이때 atoi함수를 printf 함수로 바꿔주고, 입력값으로 포맷스트링을 넣어주면 fsb가 발생, 메모리으 ㅣ값을 출력해줄것이다.
다만 이렇게 되면 더이상 atoi는 제동작을 못하기 때문에 메뉴에서 올바른 메뉴를 선택할 수 없을것 같지만,

printf 함수는 리턴값으로 출력한 문자열의 길이를 리턴하기 때문에 write를 선택하기 위해선 3글자짜리 문자열을 입력하면 된다.
메모리값을 볼 수 있는 포맷 스트링이자 3글자 길이를 가진 문자열은 %lx 이므로 , 이걸 입력해서 libc를 찾아내자.

libc를 찾아낸 다음 아까 미리 입력해둔 exit의 got를 원샷가젯으로 덮어씌우면 끝. 
unlink를 이용한 문제는 처음이어서 이해하는데에 시간이 좀 걸렸지만 이번기회에 확실하게 배운것 같다. 










